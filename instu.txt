Resumen corto (la causa)

Tu simulador est√° calculando la soluci√≥n para un choque frontal (veh√≠culos yendo uno contra otro: A ‚Üí derecha, B ‚Üí izquierda).
Para ese caso el c√°lculo que usas:

const vCM = (mA * speedA + mB * speedB) / (mA + mB);
const vRel = speedA + speedB;
const vA_final = vCM - (mB / (mA + mB)) * e * vRel;
const vB_final = vCM + (mA / (mA + mB)) * e * vRel;


produce exactamente los valores que est√°s viendo: para vA=10, vB=5, e=0.8 ‚Üí vA_final = 1.5 y vB_final = 13.5.
Eso no es un bug: es la soluci√≥n correcta para el escenario frontal/opuesto.

Lo que t√∫ (y yo en una pasada anterior) esperaban ‚ÄîvA_final = 5.5 y vB_final = 9.5‚Äî corresponde al caso ambos en la misma direcci√≥n (rear-end / colisi√≥n por alcance), donde las velocidades iniciales llevan el mismo signo (por ejemplo, A = +10, B = +5).

En resumen: hay una discrepancia entre la configuraci√≥n f√≠sica esperada (mis c√°lculos anteriores) y el modelo que tu simulador est√° usando (choque frontal).

Prueba r√°pida (num√©rica) para dejarlo claro

Caso A (mismo sentido ‚Äî rear-end):

ùë£
ùê¥
,
ùëñ
=
10
,
‚ÄÖ‚Ää
ùë£
ùêµ
,
ùëñ
=
5
,
‚ÄÖ‚Ää
ùëí
=
0.8
v
A,i
	‚Äã

=10,v
B,i
	‚Äã

=5,e=0.8 (ambos positivos)

Resultado correcto: 
ùë£
ùê¥
,
ùëì
=
5.5
,
‚ÄÖ‚Ää
ùë£
ùêµ
,
ùëì
=
9.5
v
A,f
	‚Äã

=5.5,v
B,f
	‚Äã

=9.5.

Caso B (frontal/opuestos ‚Äî tu simulador):
Si B viene en sentido contrario, su velocidad con signo es 
‚àí
5
‚àí5. Aplicando las f√≥rmulas generales se obtiene:

Resultado correcto: 
ùë£
ùê¥
,
ùëì
=
1.5
,
‚ÄÖ‚Ää
ùë£
ùêµ
,
ùëì
=
13.5
v
A,f
	‚Äã

=1.5,v
B,f
	‚Äã

=13.5.

Soluci√≥n recomendada (robusta): usar la formulaci√≥n general con signos

En lugar de asumir magnitudes y ramas separadas, usa la formulaci√≥n general que funciona para cualquier colisi√≥n 1D (rear-end o frontal). Esta usa velocidades con signo y las dos ecuaciones:

conservaci√≥n del momento: 
ùëö
ùê¥
ùë£
ùê¥
,
ùëñ
+
ùëö
ùêµ
ùë£
ùêµ
,
ùëñ
=
ùëö
ùê¥
ùë£
ùê¥
,
ùëì
+
ùëö
ùêµ
ùë£
ùêµ
,
ùëì
m
A
	‚Äã

v
A,i
	‚Äã

+m
B
	‚Äã

v
B,i
	‚Äã

=m
A
	‚Äã

v
A,f
	‚Äã

+m
B
	‚Äã

v
B,f
	‚Äã


coeficiente de restituci√≥n: 
ùëí
=
ùë£
ùêµ
,
ùëì
‚àí
ùë£
ùê¥
,
ùëì
ùë£
ùê¥
,
ùëñ
‚àí
ùë£
ùêµ
,
ùëñ
e=
v
A,i
	‚Äã

‚àív
B,i
	‚Äã

v
B,f
	‚Äã

‚àív
A,f
	‚Äã

	‚Äã


Resolviendo ese sistema obtienes (v√°lido con signos):

ùë£
ùê¥
,
ùëì
=
ùëö
ùê¥
ùë£
ùê¥
,
ùëñ
+
ùëö
ùêµ
ùë£
ùêµ
,
ùëñ
‚àí
ùëö
ùêµ
ùëí
(
ùë£
ùê¥
,
ùëñ
‚àí
ùë£
ùêµ
,
ùëñ
)
ùëö
ùê¥
+
ùëö
ùêµ
v
A,f
	‚Äã

=
m
A
	‚Äã

+m
B
	‚Äã

m
A
	‚Äã

v
A,i
	‚Äã

+m
B
	‚Äã

v
B,i
	‚Äã

‚àím
B
	‚Äã

e(v
A,i
	‚Äã

‚àív
B,i
	‚Äã

)
	‚Äã

ùë£
ùêµ
,
ùëì
=
ùëö
ùê¥
ùë£
ùê¥
,
ùëñ
+
ùëö
ùêµ
ùë£
ùêµ
,
ùëñ
+
ùëö
ùê¥
ùëí
(
ùë£
ùê¥
,
ùëñ
‚àí
ùë£
ùêµ
,
ùëñ
)
ùëö
ùê¥
+
ùëö
ùêµ
v
B,f
	‚Äã

=
m
A
	‚Äã

+m
B
	‚Äã

m
A
	‚Äã

v
A,i
	‚Äã

+m
B
	‚Äã

v
B,i
	‚Äã

+m
A
	‚Äã

e(v
A,i
	‚Äã

‚àív
B,i
	‚Äã

)
	‚Äã

Parche JS que te deja el c√°lculo correcto y expl√≠cito

Pega/reemplaza la secci√≥n donde calculas vA_final y vB_final (la parte que ahora usa vCM y vRel) por esto. Adem√°s a√±ad√≠ una opci√≥n collisionMode para que puedas elegir 'frontal' o 'mismaDireccion' (si quieres mantener interacci√≥n por UI, puedes mapear desde un select).

// --- Reemplazar el bloque actual de c√°lculo por este ---
// collisionMode: 'frontal' | 'mismaDireccion'
const collisionMode = 'frontal'; // o 'mismaDireccion' seg√∫n lo que quieras modelar

// Velocidades iniciales con signo (convenci√≥n: A -> derecha = positivo)
let vA_i = speedA;        // A siempre positivo
let vB_i;

// Dependiendo del modo, B ser√° positivo (mismo sentido) o negativo (frontal)
if (collisionMode === 'mismaDireccion') {
    vB_i = speedB;       // ambos con mismo signo
} else {
    vB_i = -speedB;      // B viene en sentido opuesto (frontal)
}

// Ahora aplicamos la f√≥rmula general (no necesitamos vCM/vRel separados)
const totalMomentum = mA * vA_i + mB * vB_i;
const dv = vA_i - vB_i; // diferencia con signos incluida

// Evitar divisi√≥n por cero si dv == 0 y e>0 (casi id√©nticas): la f√≥rmula sigue funcionando
const vA_final = ( totalMomentum - mB * e * dv ) / (mA + mB);
const vB_final = ( totalMomentum + mA * e * dv ) / (mA + mB);

// Si quieres mostrar magnitudes en la UI (sin signo), usa Math.abs cuando convenga.
// Para la animaci√≥n, asigna direction/signo seg√∫n el resultado:


Notas sobre integrar esto en tu c√≥digo actual:

Reemplaza el bloque que define vCM, vRel y las f√≥rmulas por el bloque anterior.

Si quieres mantener la l√≥gica de currentVB = -speedB para la animaci√≥n de aproximaci√≥n, no la uses para el c√°lculo f√≠sico ‚Äî usa vB_i (con signo) solo para la f√≠sica y mant√©n currentVB para la animaci√≥n previa al choque.

Al finalizar el choque, asigna currentVA = vA_final y currentVB = vB_final (incluyen signo; si ambos salen positivos, ambos ir√°n a la derecha; si uno queda negativo, ir√° a la izquierda).